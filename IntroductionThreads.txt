Eine Einführung in die Threadprogrammierung
********************************

===TOC===
1) Allgemeines
2) Einführung in POSIX-Threads
3) Thread Programmierung unter Linux
3.1) LinuxThreads (User-Threading)
3.2) NPTL
4) Thread Programmierung unter Windows

= 1 - Allgemeines =

Es wird zwischen dem User-Thread und dem Kernel-Thread unterschieden. 
Der POSIX Standard Pthreads definiert einen Satz von C-Tpyen und Funktionen, die generelles Programmieren mit Kernel-Threads bieten. Kernel-Threads werden vom Betriebssystem verwaltet. Hierbei besitzt ein Prozess entweder einen oder mehrere Threads, die jeweils gescheduled ablaufen. Jeder Prozess hat nach wie vor seinen eigenen Speicherbereich, geöffnete Dateien, ein Datensegment und ein Codesegment. Wenn der Prozess nur einen Kernel-Thread besitzt besitzt er zudem nur einen Befehlszähler und ein Stacksegment. Wenn hingegen mehrere Kernel-Threads im "Przess laufen", führt jeder Thread seinen eigenen Befehlszähler und sein eigenes Stacksegment mit. Einen Prozess mit n Threads (wobei n im Intervall [0,~) liegt) nennt man Task. 
User-Threads oder Userlevel-Threads sind keine Threads im herkömmlichen Sinne. Sie ermöglichen zwar die "parallele" Abarbeitung von Anweisungen, allerdings ist die Funktionalität dabei nicht direkt im Kernel implementiert. Der Kontextwechsel zwischen den einzelnen User-Threads übernimmt dabei eine User-Thread-Bibliothek, die somit auch über einen eigenen Scheduler verfügen muss, der nicht im Kernel, sondern im Userland ausgeführt wird. Folglich weiß das Betriebssystem nichts von der Existenz von User-Threads. Duch das Fehlen des priviligierten Prozessor-Modus kann nur kooperatives Scheduling betrieben werden. Kernel-Threads werden präemptiv gescheduled.

Implementierungen
* User-Threads
	- Linux: LinuxThreads (nicht mehr weiterentwickelt)
	- Windows: seit Windows 98 Fibers
	- JVM verwendet Green Threads, falls der JVM-Host keine Kernel-Threads bietet

* Kernel-Threads
	- Linux: Native Posix Thread Library (NPTL)
	- Windows: Funktionen der win32/64-API

Nahezu alle mordernen UNIX basierten Betriebssysteme halten sich zum Größten Teil an den POSIX-Standard. Diesen kann man auf der Webseite opengroups.org einsehen. (http://www.opengroup.org/onlinepubs/007904975/toc.htm)

= 2 - Einführung in POSIX-Threads =

Die Bezeichner aller Funktionen haben das Präfix "pthread_". Man kann die Funktionen in folgende vier Gruppen einteilen:

a) Thread Management
b) Wechselseitiger Ausschluss
c) Bedingungsvariablen
d) Synchronsiationsfunktionen


a) Thread Management
--------------------
/* Erstellung von PThreads */
int pthread_create(pthread_t *thread, const pthread_attr_t *attribute, void *(*function)(void *), void *args);
/*	-Rückgabe von 0, wenn erfolgreich
	-Retrunstatement in einer in einem Thread ausgeführten Funktion beendet den Thread
	-exit(x) in einem Thread beendet den gesamten Task, also alle Threads, die zu einem
	Prozess gehören	*/

/* Beendigung eines Threads aus einem Thread heraus */
void pthread_exit(void *returncode);

/* Warten auf die Beendigung eines anderen Threads */
void pthread_join(pthread_t *thread, void **thread_return);

/* Äquivalent zu getpid() */
pthread_t pthread_self();

Sourcecodebeispiel zum Verwenden von Threads
============================================

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void *printNum(void *num){
	for(;;){}
	return NULL;
}

int main(int argc, char ** argv){
	int i;
	pthread_t thread[8];

	/* creation of eight threads */
	for(i=0; i<8; i++){
		/* first NULL means that we want to use the standard attributes for our threads
			second NULL means that we do not need parameters */
		pthread_create(thread+i, NULL, printNum, (void *) NULL);
	}

	/* Threads won't ever return */
	for(i=0; i<8; i++){
		pthread_join(thread[i], NULL);
	}

	return EXIT_SUCCESS;
}

============================================

b) Wechselseitiger Ausschluss (Mutual Exclusion)
-----------------------------------------------
Pthreads stellt einen Mechanisumus für Mutexe bereit. Die entsprechenden Funktionen sind mit pthreads_mutex geprefixt. Die wichtigesten Funktionen sind:

* pthread_mutex_init(pthreads_mutex_t *mutex, pthread_mutexattr_t *attr)
Initialisert einen Mutex, attr kann dabei zur genaueren Konfiguration verwendet werden. Seten von attr = NULL, wenn die Standardwerte genügen. 

* pthread_mutex_destroy(pthread_mutex_t *mutex)
Entfernt einen erstellten Mutex aus dem System. Gibt 0 zurück, wenn der Aufruf erfolgreich war. Ansosnten wird ein Errorcode zurückgegeben. Mögliche Errors sind z.B.
  - EBUSY: Mutex ist noch nicht wieder freigegeben.
  - EINVAL: Es wurde eine Adresse übergeben, die keinen gültigen Mutex referenziert.
  - Siehe Manpage für weitere Details

* pthread_mutex_trylock()
Versucht den Mutex zu schließen. Gibt 0 zurück, wenn der Mutex erfolgreich geschlossen werden konnte, ansosnten wird ein Error-Code zurückgegeben. Wichtige Errorcodes sind:
  - EINVAL: Der Pointer auf den Mutex ist ungültig
  - EBUSY: Mutex konnte nicht geschlossen werden, da er zum Zeitpunkt t des Funktionsaufrufs schon geschlossen war

* pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict timeout)
Verhält sich wie pthread_mutex_lock(...), mit dem Unterschied, dass nur TIMEOUT Zeitheinheiten blockiert wird. Wenn es nicht möglich war den lock zu schließen, wird ETIMEDOUT zurückgegeben.

* pthread_mutex_lock()
Schließt einen Mutex. Wenn er bereits geschlossen war, blockiert die Funktion solange, bis der Thread, der den Mutex hält, diesen wieder freigibt. Auch hier wird 0 bei Erfolg und ein Errorcode bei einem Fehler zurückgegeben. Errorcodes sind z.B.
  - EINVAL: Falsche Parameter

* pthread_mutex_unlock()
Gibt einen geschlossenen Mutex wieder frei

* pthread_mutexattr_init(pthread_mutex_t *m)
Initialisiert ein Attributobjekt vom Typ pthread_mutexattr_t

* pthread_mutexattr_destroy(pthread_mutex_t *m)
Zerstört ein Mutexattributobjekt

Sourcecodebeispiel für die Synchonisierung mithilfe von Mutexen
==============================================================

/* Creates one(!) file pointer every thread has access to. 
	Synchronisation happens with the mutex sync which is initialized
	dynamically in the main function. */
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

#define FPATH "resource"

/* parameters */
struct f {
	FILE *fptr;
	pthread_mutex_t *mut;
	int tid;
};

/* routine executed by threads */
void *writeSth(void *data){
	struct f temp = *((struct f *) data);	
	pthread_mutex_lock(temp.mut);
	fprintf(temp.fptr, "Ich bin der Thread nummer: %d\n", temp.tid);
	pthread_mutex_unlock(temp.mut);
	return NULL;
}

int main(int argc, char ** argv){
	int i;
	struct f data[8];
	FILE *file = fopen(FPATH, "w+");
	pthread_t thread[8];

	/* create the mutex */
	pthread_mutex_t sync; 
	pthread_mutex_init(&sync, NULL);

	/* starts threads and passes arguments */
	for(i=0; i<8; i++){
		data[i].fptr = file;
		data[i].tid = i;
		data[i].mut = &sync;

		pthread_create(thread+i, NULL, writeSth, (void *) (data+i));
	}

	/* waits for all threads */
	for(i=0; i<8; i++){
		pthread_join(thread[i], NULL);
	}

	/* free the resources taken by the mutex */
	pthread_mutex_destroy(&sync);
	return EXIT_SUCCESS;
}

==============================================================


c) Bedingungsvariablen

Locks verhalten sich wie Semaphore, die mit dem Wert eins initialisiert wurden. Nur ein Thread kann bei dieser Art der Synchronsiation gleichzeitig in den kritischen Abschnitt. Bei komplexeren Problemen wie z.B. dem Erzeuger-Verbraucher-Problem ist es jedoch notwendig bis zu n Threads gleichzeitig in einem zu synchronisierenden Abschnitt arbeiten zu lassen. Dies wird durch die Kombination von Mutexen und Bedingungsvariablen ermöglicht.

Bei der Verwendung geht man nach den folgenden Schritten vor:

* Initialisierung von globalem Speicher, dessen Bearbeitung synchronisiert werden muss
* Initialisierung einer Bedingungsvariable (Umgesetzt als Objekt der Pthreads-Bibliothek)
* Initialisierung eines Mutexes mit Bezug auf die Bedingungsvariable
* Erstellung der Threads.


Pthreads bietet folgende Funktionen für die Erstellung, Bearbeitung und Vernichtung von Bedingungsvariablen.

* pthreads_cond_init(pthread_cond_t *c, const pthread_condattr_t *restrict a)
Initialisert ein zuvor deklariertes Objekt vom Typ pthread_cond. Dabei 

* pthread_cond_destroy(pthread_cond_t *c)
* pthread_condattr_init(pthread_condattr_t *c)
Initialisert ein zuvor deklariertes Objekt vom Typ pthread_condattr_t. Die

* pthread_condattr_destroy(pthread_condattr_t *c)
* pthread_cond
* pthread_cond
* pthread_cond
* pthread_cond


= 4 - Thread Programmierung unter Windows =

Das Buch C von A bis Z liefert einen guten Überblick über die Funktionen der PThreads-Library und deren Anwendung. Das Entsprechende Kaptiel hat die Nummer 26. Das Buch ist als Openbook (Stand Feb. 2014) auf der Webseite des Verlags zu finden: http://openbook.galileocomputing.de/c_von_a_bis_z/026_c_paralleles_rechnen_004.htm 

